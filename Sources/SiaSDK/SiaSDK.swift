// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SiaSDKFFI)
import SiaSDKFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_indexd_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_indexd_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureIndexdFfiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}




/**
 * An AppKey is used to sign requests to the indexer.
 *
 * AppKeys can be registered with an indexer during
 * onboarding with a [Builder]. They are derived from
 * a BIP-32 recovery phrase, which can be generated
 * using [generate_recovery_phrase].
 *
 * It must be stored securely by the application and
 * never shared publicly. If exposed, a user's data
 * is compromised.
 *
 * Mishandling the app key will lead to data loss
 * and inability to access stored objects.
 */
public protocol AppKeyProtocol: AnyObject, Sendable {
    
    /**
     * Exports the AppKey. The app key can be re-imported later
     * using [AppKey::new].
     *
     * AppKeys should be stored securely by the application in lieu of the
     * recovery phrase.
     */
    func export()  -> Data
    
    /**
     * Returns the public key corresponding to the AppKey.
     *
     * This can be safely shared with others.
     */
    func publicKey()  -> String
    
    /**
     * Signs a message using the AppKey.
     */
    func sign(message: Data)  -> Data
    
    /**
     * Verifies a signature for a given message using the AppKey.
     */
    func verifySignature(message: Data, signature: Data) throws  -> Bool
    
}
/**
 * An AppKey is used to sign requests to the indexer.
 *
 * AppKeys can be registered with an indexer during
 * onboarding with a [Builder]. They are derived from
 * a BIP-32 recovery phrase, which can be generated
 * using [generate_recovery_phrase].
 *
 * It must be stored securely by the application and
 * never shared publicly. If exposed, a user's data
 * is compromised.
 *
 * Mishandling the app key will lead to data loss
 * and inability to access stored objects.
 */
open class AppKey: AppKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_appkey(self.pointer, $0) }
    }
    /**
     * Imports an AppKey from the provided byte array.
     *
     * # Arguments
     * * `key` - A 32-byte array representing the app key.
     */
public convenience init(key: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeAppKeyError_lift) {
    uniffi_indexd_ffi_fn_constructor_appkey_new(
        FfiConverterData.lower(key),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_appkey(pointer, $0) }
    }

    

    
    /**
     * Exports the AppKey. The app key can be re-imported later
     * using [AppKey::new].
     *
     * AppKeys should be stored securely by the application in lieu of the
     * recovery phrase.
     */
open func export() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_appkey_export(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the public key corresponding to the AppKey.
     *
     * This can be safely shared with others.
     */
open func publicKey() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_appkey_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Signs a message using the AppKey.
     */
open func sign(message: Data) -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_appkey_sign(self.uniffiClonePointer(),
        FfiConverterData.lower(message),$0
    )
})
}
    
    /**
     * Verifies a signature for a given message using the AppKey.
     */
open func verifySignature(message: Data, signature: Data)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeAppKeyError_lift) {
    uniffi_indexd_ffi_fn_method_appkey_verify_signature(self.uniffiClonePointer(),
        FfiConverterData.lower(message),
        FfiConverterData.lower(signature),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AppKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AppKey {
        return AppKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AppKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AppKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> AppKey {
    return try FfiConverterTypeAppKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppKey_lower(_ value: AppKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAppKey.lower(value)
}






public protocol BuilderProtocol: AnyObject, Sendable {
    
    /**
     * Attempts to connect using the provided app key and TLS configuration.
     * If the app key is valid, returns Some([SDK]), otherwise returns None.
     *
     * If you receive None, call [Builder::request_connection] to request a new connection.
     *
     * # Arguments
     * * `app_key` - The application key used for authentication.
     */
    func connected(appKey: AppKey) async throws  -> Sdk?
    
    /**
     * Registers the application with the indexer using the provided mnemonic.
     * Once registered, returns an [SDK] instance that can be used to interact
     * with the indexer.
     *
     * # Arguments
     * * `mnemonic` - The user's mnemonic phrase used to derive the application key.
     */
    func register(mnemonic: String) async throws  -> Sdk
    
    /**
     * Requests a new connection for the application.
     *
     * # Arguments
     * * `app` - Details of the application requesting connection.
     */
    func requestConnection(meta: AppMeta) async throws  -> Builder
    
    /**
     * Retrieves the response URL for the connection request.
     * This URL can be used to approve the connection request.
     * It should be displayed to the user.
     */
    func responseUrl() throws  -> String
    
    /**
     * Waits for the connection request to be approved.
     * Once approved, the app can be registered and used to create an
     * SDK instance.
     */
    func waitForApproval() async throws  -> Builder
    
}
open class Builder: BuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_builder(self.pointer, $0) }
    }
    /**
     * Creates a new SDK builder with the provided indexer URL.
     *
     * After creating the builder, call [Builder::connected] to attempt
     * to connect using an existing app key, or [Builder::request_connection]
     * to request a new connection.
     */
public convenience init(indexerUrl: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBuilderError_lift) {
    uniffi_indexd_ffi_fn_constructor_builder_new(
        FfiConverterString.lower(indexerUrl),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_builder(pointer, $0) }
    }

    

    
    /**
     * Attempts to connect using the provided app key and TLS configuration.
     * If the app key is valid, returns Some([SDK]), otherwise returns None.
     *
     * If you receive None, call [Builder::request_connection] to request a new connection.
     *
     * # Arguments
     * * `app_key` - The application key used for authentication.
     */
open func connected(appKey: AppKey)async throws  -> Sdk?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_builder_connected(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAppKey_lower(appKey)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeSDK.lift,
            errorHandler: FfiConverterTypeBuilderError_lift
        )
}
    
    /**
     * Registers the application with the indexer using the provided mnemonic.
     * Once registered, returns an [SDK] instance that can be used to interact
     * with the indexer.
     *
     * # Arguments
     * * `mnemonic` - The user's mnemonic phrase used to derive the application key.
     */
open func register(mnemonic: String)async throws  -> Sdk  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_builder_register(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(mnemonic)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSDK_lift,
            errorHandler: FfiConverterTypeBuilderError_lift
        )
}
    
    /**
     * Requests a new connection for the application.
     *
     * # Arguments
     * * `app` - Details of the application requesting connection.
     */
open func requestConnection(meta: AppMeta)async throws  -> Builder  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_builder_request_connection(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAppMeta_lower(meta)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBuilder_lift,
            errorHandler: FfiConverterTypeBuilderError_lift
        )
}
    
    /**
     * Retrieves the response URL for the connection request.
     * This URL can be used to approve the connection request.
     * It should be displayed to the user.
     */
open func responseUrl()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBuilderError_lift) {
    uniffi_indexd_ffi_fn_method_builder_response_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Waits for the connection request to be approved.
     * Once approved, the app can be registered and used to create an
     * SDK instance.
     */
open func waitForApproval()async throws  -> Builder  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_builder_wait_for_approval(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBuilder_lift,
            errorHandler: FfiConverterTypeBuilderError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Builder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
        return Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Builder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
    return try FfiConverterTypeBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilder_lower(_ value: Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBuilder.lower(value)
}






public protocol EncryptionKeyProtocol: AnyObject, Sendable {
    
    /**
     * Exports the key as a base64 encoded string.
     *
     * This should be used to store the key securely.
     * The key should never be shared or transmitted
     * in plaintext.
     */
    func export()  -> String
    
}
open class EncryptionKey: EncryptionKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_encryptionkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_encryptionkey(pointer, $0) }
    }

    
public static func parse(str: String)throws  -> EncryptionKey  {
    return try  FfiConverterTypeEncryptionKey_lift(try rustCallWithError(FfiConverterTypeEncryptionKeyParseError_lift) {
    uniffi_indexd_ffi_fn_constructor_encryptionkey_parse(
        FfiConverterString.lower(str),$0
    )
})
}
    

    
    /**
     * Exports the key as a base64 encoded string.
     *
     * This should be used to store the key securely.
     * The key should never be shared or transmitted
     * in plaintext.
     */
open func export() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_encryptionkey_export(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptionKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptionKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptionKey {
        return EncryptionKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptionKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptionKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptionKey {
    return try FfiConverterTypeEncryptionKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKey_lower(_ value: EncryptionKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptionKey.lower(value)
}






public protocol Logger: AnyObject, Sendable {
    
    func info(msg: String) 
    
    func warn(msg: String) 
    
    func error(msg: String) 
    
    func debug(msg: String) 
    
}
open class LoggerImpl: Logger, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_logger(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_logger(pointer, $0) }
    }

    

    
open func info(msg: String)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_logger_info(self.uniffiClonePointer(),
        FfiConverterString.lower(msg),$0
    )
}
}
    
open func warn(msg: String)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_logger_warn(self.uniffiClonePointer(),
        FfiConverterString.lower(msg),$0
    )
}
}
    
open func error(msg: String)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_logger_error(self.uniffiClonePointer(),
        FfiConverterString.lower(msg),$0
    )
}
}
    
open func debug(msg: String)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_logger_debug(self.uniffiClonePointer(),
        FfiConverterString.lower(msg),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLogger] = [UniffiVTableCallbackInterfaceLogger(
        info: { (
            uniffiHandle: UInt64,
            msg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.info(
                     msg: try FfiConverterString.lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        warn: { (
            uniffiHandle: UInt64,
            msg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.warn(
                     msg: try FfiConverterString.lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        error: { (
            uniffiHandle: UInt64,
            msg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.error(
                     msg: try FfiConverterString.lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        debug: { (
            uniffiHandle: UInt64,
            msg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.debug(
                     msg: try FfiConverterString.lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLogger() {
    uniffi_indexd_ffi_fn_init_callback_vtable_logger(UniffiCallbackInterfaceLogger.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogger: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Logger>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Logger

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
        return LoggerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Logger) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Logger {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Logger, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
    return try FfiConverterTypeLogger.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lower(_ value: Logger) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogger.lower(value)
}






/**
 * A packed upload allows multiple objects to be uploaded together in a single upload. This can be more
 * efficient than uploading each object separately if the size of the object is less than the minimum
 * slab size.
 */
public protocol PackedUploadProtocol: AnyObject, Sendable {
    
    /**
     * Adds a new object to the upload. The data will be read until EOF and packed into
     * the upload. The resulting object will contain the metadata needed to download the object. The caller
     * must call [finalize](Self::finalize) to get the resulting objects after all objects have been added.
     */
    func add(reader: Reader) async throws  -> UInt64
    
    /**
     * Finalizes the upload and returns the resulting objects. This will wait for all readers
     * to finish and all slabs to be uploaded before returning. The resulting objects will contain the metadata needed to download the objects.
     *
     * The caller must pin the resulting objects to the indexer when ready.
     */
    func finalize() async throws  -> [PinnedObject]
    
    /**
     * Returns the number of bytes remaining until reaching the optimal
     * packed size. Adding objects larger than this will start a new slab.
     * To minimize padding, prioritize objects that fit within the remaining
     * size.
     */
    func remaining() async throws  -> UInt64
    
}
/**
 * A packed upload allows multiple objects to be uploaded together in a single upload. This can be more
 * efficient than uploading each object separately if the size of the object is less than the minimum
 * slab size.
 */
open class PackedUpload: PackedUploadProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_packedupload(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_packedupload(pointer, $0) }
    }

    

    
    /**
     * Adds a new object to the upload. The data will be read until EOF and packed into
     * the upload. The resulting object will contain the metadata needed to download the object. The caller
     * must call [finalize](Self::finalize) to get the resulting objects after all objects have been added.
     */
open func add(reader: Reader)async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_packedupload_add(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReader_lower(reader)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_u64,
            completeFunc: ffi_indexd_ffi_rust_future_complete_u64,
            freeFunc: ffi_indexd_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeUploadError_lift
        )
}
    
    /**
     * Finalizes the upload and returns the resulting objects. This will wait for all readers
     * to finish and all slabs to be uploaded before returning. The resulting objects will contain the metadata needed to download the objects.
     *
     * The caller must pin the resulting objects to the indexer when ready.
     */
open func finalize()async throws  -> [PinnedObject]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_packedupload_finalize(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePinnedObject.lift,
            errorHandler: FfiConverterTypeUploadError_lift
        )
}
    
    /**
     * Returns the number of bytes remaining until reaching the optimal
     * packed size. Adding objects larger than this will start a new slab.
     * To minimize padding, prioritize objects that fit within the remaining
     * size.
     */
open func remaining()async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_packedupload_remaining(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_u64,
            completeFunc: ffi_indexd_ffi_rust_future_complete_u64,
            freeFunc: ffi_indexd_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeUploadError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePackedUpload: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PackedUpload

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PackedUpload {
        return PackedUpload(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PackedUpload) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackedUpload {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PackedUpload, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePackedUpload_lift(_ pointer: UnsafeMutableRawPointer) throws -> PackedUpload {
    return try FfiConverterTypePackedUpload.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePackedUpload_lower(_ value: PackedUpload) -> UnsafeMutableRawPointer {
    return FfiConverterTypePackedUpload.lower(value)
}






/**
 * An object that has been pinned to an indexer. Objects are immutable
 * data stored on the Sia network. The data is erasure-coded and distributed across
 * multiple storage providers. The object is encrypted with a unique encryption key,
 * which is used to encrypt the metadata.
 *
 * Custom user-defined metadata can be associated with the object. It is
 * recommended to use a portable format like JSON for metadata.
 *
 * It can be sealed for secure offline storage or transmission and
 * later opened using the app key.
 *
 * It has no public fields to prevent accidental leakage or corruption.
 */
public protocol PinnedObjectProtocol: AnyObject, Sendable {
    
    /**
     * Returns the time the object was created.
     */
    func createdAt()  -> Date
    
    /**
     * Returns the object's ID, which is the Blake2b hash of its slabs.
     */
    func id()  -> String
    
    /**
     * Returns the metadata associated with the object.
     */
    func metadata()  -> Data
    
    /**
     * Seal the object for offline storage.
     * # Arguments
     * * `app_key` - The app key used to derive the master key to encrypt the object's encryption key.
     *
     * # Returns
     * The sealed object.
     */
    func seal(appKey: AppKey)  -> SealedObject
    
    /**
     * Returns the total size of the object by summing the lengths of its slabs.
     */
    func size()  -> UInt64
    
    /**
     * Returns the slabs that make up the object.
     */
    func slabs()  -> [Slab]
    
    /**
     * Updates the metadata associated with the object.
     */
    func updateMetadata(metadata: Data) 
    
    /**
     * Returns the time the object was last updated.
     */
    func updatedAt()  -> Date
    
}
/**
 * An object that has been pinned to an indexer. Objects are immutable
 * data stored on the Sia network. The data is erasure-coded and distributed across
 * multiple storage providers. The object is encrypted with a unique encryption key,
 * which is used to encrypt the metadata.
 *
 * Custom user-defined metadata can be associated with the object. It is
 * recommended to use a portable format like JSON for metadata.
 *
 * It can be sealed for secure offline storage or transmission and
 * later opened using the app key.
 *
 * It has no public fields to prevent accidental leakage or corruption.
 */
open class PinnedObject: PinnedObjectProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_pinnedobject(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_pinnedobject(pointer, $0) }
    }

    
    /**
     * Opens a sealed object using the provided app key.
     *
     * # Arguments
     * * `app_key` - The app key that was used to seal the object.
     * * `sealed` - The sealed object to open.
     *
     * # Returns
     * The unsealed object or an error if the object could not be opened.
     */
public static func `open`(appKey: AppKey, sealed: SealedObject)throws  -> PinnedObject  {
    return try  FfiConverterTypePinnedObject_lift(try rustCallWithError(FfiConverterTypeObjectError_lift) {
    uniffi_indexd_ffi_fn_constructor_pinnedobject_open(
        FfiConverterTypeAppKey_lower(appKey),
        FfiConverterTypeSealedObject_lower(sealed),$0
    )
})
}
    

    
    /**
     * Returns the time the object was created.
     */
open func createdAt() -> Date  {
    return try!  FfiConverterTimestamp.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the object's ID, which is the Blake2b hash of its slabs.
     */
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the metadata associated with the object.
     */
open func metadata() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Seal the object for offline storage.
     * # Arguments
     * * `app_key` - The app key used to derive the master key to encrypt the object's encryption key.
     *
     * # Returns
     * The sealed object.
     */
open func seal(appKey: AppKey) -> SealedObject  {
    return try!  FfiConverterTypeSealedObject_lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_seal(self.uniffiClonePointer(),
        FfiConverterTypeAppKey_lower(appKey),$0
    )
})
}
    
    /**
     * Returns the total size of the object by summing the lengths of its slabs.
     */
open func size() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_size(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the slabs that make up the object.
     */
open func slabs() -> [Slab]  {
    return try!  FfiConverterSequenceTypeSlab.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_slabs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Updates the metadata associated with the object.
     */
open func updateMetadata(metadata: Data)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_update_metadata(self.uniffiClonePointer(),
        FfiConverterData.lower(metadata),$0
    )
}
}
    
    /**
     * Returns the time the object was last updated.
     */
open func updatedAt() -> Date  {
    return try!  FfiConverterTimestamp.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_pinnedobject_updated_at(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePinnedObject: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PinnedObject

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PinnedObject {
        return PinnedObject(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PinnedObject) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PinnedObject {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PinnedObject, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedObject_lift(_ pointer: UnsafeMutableRawPointer) throws -> PinnedObject {
    return try FfiConverterTypePinnedObject.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedObject_lower(_ value: PinnedObject) -> UnsafeMutableRawPointer {
    return FfiConverterTypePinnedObject.lower(value)
}






/**
 * A foreign reader that can be used to transfer data across FFI boundaries.
 *
 * Implementations should send an empty chunk to signal completion. It is recommended
 * that implementations chunk data into reasonably sized pieces (e.g. 64KiB) to avoid
 * excessive memory usage.
 *
 * If an error is returned by `read`, the reader will be closed and no
 * further calls will be made.
 */
public protocol Reader: AnyObject, Sendable {
    
    func read() async throws  -> Data
    
}
/**
 * A foreign reader that can be used to transfer data across FFI boundaries.
 *
 * Implementations should send an empty chunk to signal completion. It is recommended
 * that implementations chunk data into reasonably sized pieces (e.g. 64KiB) to avoid
 * excessive memory usage.
 *
 * If an error is returned by `read`, the reader will be closed and no
 * further calls will be made.
 */
open class ReaderImpl: Reader, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_reader(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_reader(pointer, $0) }
    }

    

    
open func read()async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_reader_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeIOError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceReader {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceReader] = [UniffiVTableCallbackInterfaceReader(
        read: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeReader.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.read(
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeIOError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeReader.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Reader: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitReader() {
    uniffi_indexd_ffi_fn_init_callback_vtable_reader(UniffiCallbackInterfaceReader.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReader: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Reader>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Reader

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Reader {
        return ReaderImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Reader) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reader {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Reader, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReader_lift(_ pointer: UnsafeMutableRawPointer) throws -> Reader {
    return try FfiConverterTypeReader.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReader_lower(_ value: Reader) -> UnsafeMutableRawPointer {
    return FfiConverterTypeReader.lower(value)
}






public protocol SdkProtocol: AnyObject, Sendable {
    
    /**
     * Returns the current account.
     */
    func account() async throws  -> Account
    
    /**
     * Returns the application key used by the SDK.
     *
     * This should be kept secret and secure. Applications
     * must never share their app key publicly. Store
     * it safely.
     */
    func appKey()  -> AppKey
    
    /**
     * Deletes an object from the indexer.
     */
    func deleteObject(key: String) async throws 
    
    /**
     * Initiates a download of the data referenced by the object, starting at `offset` and reading `length` bytes.
     */
    func download(w: Writer, object: PinnedObject, options: DownloadOptions) async throws 
    
    /**
     * Returns a list of all usable hosts.
     */
    func hosts() async throws  -> [Host]
    
    /**
     * Returns metadata about a specific object stored in the indexer.
     */
    func object(key: String) async throws  -> PinnedObject
    
    /**
     * Returns objects stored in the indexer. When syncing, the caller should
     * provide the last `updated_at` timestamp and `id` seen in the `cursor`
     * parameter to avoid missing or duplicating objects.
     *
     * # Arguments
     * * `cursor` can be used to paginate through the results. If `cursor` is `None`, the first page of results will be returned.
     * * `limit` specifies the maximum number of objects to return.
     */
    func objectEvents(cursor: ObjectsCursor?, limit: UInt32) async throws  -> [ObjectEvent]
    
    /**
     * Pins an object to the indexer
     */
    func pinObject(object: PinnedObject) async throws 
    
    /**
     * Unpins slabs not used by any object on the account.
     */
    func pruneSlabs() async throws 
    
    /**
     * Creates a signed URL that can be used to share object metadata
     * with other people using an indexer.
     */
    func shareObject(object: PinnedObject, validUntil: Date) throws  -> String
    
    /**
     * Retrieves a shared object from a signed URL.
     */
    func sharedObject(sharedUrl: String) async throws  -> PinnedObject
    
    /**
     * Returns metadata about a slab stored in the indexer.
     */
    func slab(slabId: String) async throws  -> PinnedSlab
    
    /**
     * Updates the metadata of an object stored in the indexer. The object must already be pinned to
     * the indexer.
     */
    func updateObjectMetadata(object: PinnedObject) async throws 
    
    /**
     * Uploads data to the Sia network and pins it to the indexer
     *
     * # Arguments
     * * `options` - The [UploadOptions] to use for the upload
     *
     * # Returns
     * An object representing the uploaded data.
     */
    func upload(r: Reader, options: UploadOptions) async throws  -> PinnedObject
    
    /**
     * Creates a new packed upload. This allows multiple objects to be packed together
     * for more efficient uploads. The returned `PackedUpload` can be used to add objects to the upload, and then finalized to get the resulting objects.
     *
     * # Arguments
     * * `options` - The [UploadOptions] to use for the upload.
     *
     * # Returns
     * A [PackedUpload] that can be used to add objects and finalize the upload.
     */
    func uploadPacked(options: UploadOptions) async  -> PackedUpload
    
}
open class Sdk: SdkProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_sdk(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_sdk(pointer, $0) }
    }

    

    
    /**
     * Returns the current account.
     */
open func account()async throws  -> Account  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_account(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAccount_lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Returns the application key used by the SDK.
     *
     * This should be kept secret and secure. Applications
     * must never share their app key publicly. Store
     * it safely.
     */
open func appKey() -> AppKey  {
    return try!  FfiConverterTypeAppKey_lift(try! rustCall() {
    uniffi_indexd_ffi_fn_method_sdk_app_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Deletes an object from the indexer.
     */
open func deleteObject(key: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_delete_object(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Initiates a download of the data referenced by the object, starting at `offset` and reading `length` bytes.
     */
open func download(w: Writer, object: PinnedObject, options: DownloadOptions)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_download(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWriter_lower(w),FfiConverterTypePinnedObject_lower(object),FfiConverterTypeDownloadOptions_lower(options)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeDownloadError_lift
        )
}
    
    /**
     * Returns a list of all usable hosts.
     */
open func hosts()async throws  -> [Host]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_hosts(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHost.lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Returns metadata about a specific object stored in the indexer.
     */
open func object(key: String)async throws  -> PinnedObject  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_object(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePinnedObject_lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Returns objects stored in the indexer. When syncing, the caller should
     * provide the last `updated_at` timestamp and `id` seen in the `cursor`
     * parameter to avoid missing or duplicating objects.
     *
     * # Arguments
     * * `cursor` can be used to paginate through the results. If `cursor` is `None`, the first page of results will be returned.
     * * `limit` specifies the maximum number of objects to return.
     */
open func objectEvents(cursor: ObjectsCursor?, limit: UInt32)async throws  -> [ObjectEvent]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_object_events(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeObjectsCursor.lower(cursor),FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeObjectEvent.lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Pins an object to the indexer
     */
open func pinObject(object: PinnedObject)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_pin_object(
                    self.uniffiClonePointer(),
                    FfiConverterTypePinnedObject_lower(object)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Unpins slabs not used by any object on the account.
     */
open func pruneSlabs()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_prune_slabs(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Creates a signed URL that can be used to share object metadata
     * with other people using an indexer.
     */
open func shareObject(object: PinnedObject, validUntil: Date)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeError_lift) {
    uniffi_indexd_ffi_fn_method_sdk_share_object(self.uniffiClonePointer(),
        FfiConverterTypePinnedObject_lower(object),
        FfiConverterTimestamp.lower(validUntil),$0
    )
})
}
    
    /**
     * Retrieves a shared object from a signed URL.
     */
open func sharedObject(sharedUrl: String)async throws  -> PinnedObject  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_shared_object(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(sharedUrl)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePinnedObject_lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Returns metadata about a slab stored in the indexer.
     */
open func slab(slabId: String)async throws  -> PinnedSlab  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_slab(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(slabId)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_indexd_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePinnedSlab_lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Updates the metadata of an object stored in the indexer. The object must already be pinned to
     * the indexer.
     */
open func updateObjectMetadata(object: PinnedObject)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_update_object_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypePinnedObject_lower(object)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeError_lift
        )
}
    
    /**
     * Uploads data to the Sia network and pins it to the indexer
     *
     * # Arguments
     * * `options` - The [UploadOptions] to use for the upload
     *
     * # Returns
     * An object representing the uploaded data.
     */
open func upload(r: Reader, options: UploadOptions)async throws  -> PinnedObject  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_upload(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReader_lower(r),FfiConverterTypeUploadOptions_lower(options)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePinnedObject_lift,
            errorHandler: FfiConverterTypeUploadError_lift
        )
}
    
    /**
     * Creates a new packed upload. This allows multiple objects to be packed together
     * for more efficient uploads. The returned `PackedUpload` can be used to add objects to the upload, and then finalized to get the resulting objects.
     *
     * # Arguments
     * * `options` - The [UploadOptions] to use for the upload.
     *
     * # Returns
     * A [PackedUpload] that can be used to add objects and finalize the upload.
     */
open func uploadPacked(options: UploadOptions)async  -> PackedUpload  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_sdk_upload_packed(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUploadOptions_lower(options)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_pointer,
            completeFunc: ffi_indexd_ffi_rust_future_complete_pointer,
            freeFunc: ffi_indexd_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePackedUpload_lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSDK: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Sdk

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Sdk {
        return Sdk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Sdk) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sdk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Sdk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSDK_lift(_ pointer: UnsafeMutableRawPointer) throws -> Sdk {
    return try FfiConverterTypeSDK.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSDK_lower(_ value: Sdk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSDK.lower(value)
}






public protocol UploadProgressCallback: AnyObject, Sendable {
    
    func progress(uploaded: UInt64, encodedSize: UInt64) 
    
}
open class UploadProgressCallbackImpl: UploadProgressCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_uploadprogresscallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_uploadprogresscallback(pointer, $0) }
    }

    

    
open func progress(uploaded: UInt64, encodedSize: UInt64)  {try! rustCall() {
    uniffi_indexd_ffi_fn_method_uploadprogresscallback_progress(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(uploaded),
        FfiConverterUInt64.lower(encodedSize),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceUploadProgressCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceUploadProgressCallback] = [UniffiVTableCallbackInterfaceUploadProgressCallback(
        progress: { (
            uniffiHandle: UInt64,
            uploaded: UInt64,
            encodedSize: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeUploadProgressCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.progress(
                     uploaded: try FfiConverterUInt64.lift(uploaded),
                     encodedSize: try FfiConverterUInt64.lift(encodedSize)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeUploadProgressCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UploadProgressCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitUploadProgressCallback() {
    uniffi_indexd_ffi_fn_init_callback_vtable_uploadprogresscallback(UniffiCallbackInterfaceUploadProgressCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadProgressCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<UploadProgressCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UploadProgressCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UploadProgressCallback {
        return UploadProgressCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UploadProgressCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadProgressCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UploadProgressCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadProgressCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> UploadProgressCallback {
    return try FfiConverterTypeUploadProgressCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadProgressCallback_lower(_ value: UploadProgressCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUploadProgressCallback.lower(value)
}






/**
 * A foreign writer that can be used to transfer data across FFI boundaries.
 * The data may be sent in multiple chunks. The implementation should handle
 * buffering and writing the data as it is received.
 */
public protocol Writer: AnyObject, Sendable {
    
    func write(data: Data) async throws 
    
}
/**
 * A foreign writer that can be used to transfer data across FFI boundaries.
 * The data may be sent in multiple chunks. The implementation should handle
 * buffering and writing the data as it is received.
 */
open class WriterImpl: Writer, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_indexd_ffi_fn_clone_writer(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_indexd_ffi_fn_free_writer(pointer, $0) }
    }

    

    
open func write(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_indexd_ffi_fn_method_writer_write(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_indexd_ffi_rust_future_poll_void,
            completeFunc: ffi_indexd_ffi_rust_future_complete_void,
            freeFunc: ffi_indexd_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeIOError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWriter {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWriter] = [UniffiVTableCallbackInterfaceWriter(
        write: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeWriter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.write(
                     data: try FfiConverterData.lift(data)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeIOError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeWriter.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Writer: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitWriter() {
    uniffi_indexd_ffi_fn_init_callback_vtable_writer(UniffiCallbackInterfaceWriter.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWriter: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Writer>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Writer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Writer {
        return WriterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Writer) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Writer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Writer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWriter_lift(_ pointer: UnsafeMutableRawPointer) throws -> Writer {
    return try FfiConverterTypeWriter.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWriter_lower(_ value: Writer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWriter.lower(value)
}




/**
 * An account registered on the indexer.
 */
public struct Account {
    public var accountKey: String
    public var maxPinnedData: UInt64
    public var pinnedData: UInt64
    public var app: App
    public var lastUsed: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountKey: String, maxPinnedData: UInt64, pinnedData: UInt64, app: App, lastUsed: Date) {
        self.accountKey = accountKey
        self.maxPinnedData = maxPinnedData
        self.pinnedData = pinnedData
        self.app = app
        self.lastUsed = lastUsed
    }
}

#if compiler(>=6)
extension Account: Sendable {}
#endif


extension Account: Equatable, Hashable {
    public static func ==(lhs: Account, rhs: Account) -> Bool {
        if lhs.accountKey != rhs.accountKey {
            return false
        }
        if lhs.maxPinnedData != rhs.maxPinnedData {
            return false
        }
        if lhs.pinnedData != rhs.pinnedData {
            return false
        }
        if lhs.app != rhs.app {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountKey)
        hasher.combine(maxPinnedData)
        hasher.combine(pinnedData)
        hasher.combine(app)
        hasher.combine(lastUsed)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                accountKey: FfiConverterString.read(from: &buf), 
                maxPinnedData: FfiConverterUInt64.read(from: &buf), 
                pinnedData: FfiConverterUInt64.read(from: &buf), 
                app: FfiConverterTypeApp.read(from: &buf), 
                lastUsed: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accountKey, into: &buf)
        FfiConverterUInt64.write(value.maxPinnedData, into: &buf)
        FfiConverterUInt64.write(value.pinnedData, into: &buf)
        FfiConverterTypeApp.write(value.app, into: &buf)
        FfiConverterTimestamp.write(value.lastUsed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}


public struct App {
    public var id: String
    public var description: String
    public var serviceUrl: String?
    public var logoUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, description: String, serviceUrl: String?, logoUrl: String?) {
        self.id = id
        self.description = description
        self.serviceUrl = serviceUrl
        self.logoUrl = logoUrl
    }
}

#if compiler(>=6)
extension App: Sendable {}
#endif


extension App: Equatable, Hashable {
    public static func ==(lhs: App, rhs: App) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.serviceUrl != rhs.serviceUrl {
            return false
        }
        if lhs.logoUrl != rhs.logoUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(description)
        hasher.combine(serviceUrl)
        hasher.combine(logoUrl)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> App {
        return
            try App(
                id: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                serviceUrl: FfiConverterOptionString.read(from: &buf), 
                logoUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: App, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.serviceUrl, into: &buf)
        FfiConverterOptionString.write(value.logoUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApp_lift(_ buf: RustBuffer) throws -> App {
    return try FfiConverterTypeApp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApp_lower(_ value: App) -> RustBuffer {
    return FfiConverterTypeApp.lower(value)
}


/**
 * Metadata about an application connecting to the indexer.
 */
public struct AppMeta {
    public var id: Data
    public var name: String
    public var description: String
    public var serviceUrl: String
    public var logoUrl: String?
    public var callbackUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, name: String, description: String, serviceUrl: String, logoUrl: String?, callbackUrl: String?) {
        self.id = id
        self.name = name
        self.description = description
        self.serviceUrl = serviceUrl
        self.logoUrl = logoUrl
        self.callbackUrl = callbackUrl
    }
}

#if compiler(>=6)
extension AppMeta: Sendable {}
#endif


extension AppMeta: Equatable, Hashable {
    public static func ==(lhs: AppMeta, rhs: AppMeta) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.serviceUrl != rhs.serviceUrl {
            return false
        }
        if lhs.logoUrl != rhs.logoUrl {
            return false
        }
        if lhs.callbackUrl != rhs.callbackUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(serviceUrl)
        hasher.combine(logoUrl)
        hasher.combine(callbackUrl)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppMeta: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppMeta {
        return
            try AppMeta(
                id: FfiConverterData.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                serviceUrl: FfiConverterString.read(from: &buf), 
                logoUrl: FfiConverterOptionString.read(from: &buf), 
                callbackUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AppMeta, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.serviceUrl, into: &buf)
        FfiConverterOptionString.write(value.logoUrl, into: &buf)
        FfiConverterOptionString.write(value.callbackUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppMeta_lift(_ buf: RustBuffer) throws -> AppMeta {
    return try FfiConverterTypeAppMeta.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppMeta_lower(_ value: AppMeta) -> RustBuffer {
    return FfiConverterTypeAppMeta.lower(value)
}


/**
 * Provides options for a download operation.
 */
public struct DownloadOptions {
    public var maxInflight: UInt8
    public var offset: UInt64
    public var length: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxInflight: UInt8 = UInt8(10), offset: UInt64 = UInt64(0), length: UInt64? = nil) {
        self.maxInflight = maxInflight
        self.offset = offset
        self.length = length
    }
}

#if compiler(>=6)
extension DownloadOptions: Sendable {}
#endif


extension DownloadOptions: Equatable, Hashable {
    public static func ==(lhs: DownloadOptions, rhs: DownloadOptions) -> Bool {
        if lhs.maxInflight != rhs.maxInflight {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxInflight)
        hasher.combine(offset)
        hasher.combine(length)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDownloadOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DownloadOptions {
        return
            try DownloadOptions(
                maxInflight: FfiConverterUInt8.read(from: &buf), 
                offset: FfiConverterUInt64.read(from: &buf), 
                length: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DownloadOptions, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.maxInflight, into: &buf)
        FfiConverterUInt64.write(value.offset, into: &buf)
        FfiConverterOptionUInt64.write(value.length, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadOptions_lift(_ buf: RustBuffer) throws -> DownloadOptions {
    return try FfiConverterTypeDownloadOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadOptions_lower(_ value: DownloadOptions) -> RustBuffer {
    return FfiConverterTypeDownloadOptions.lower(value)
}


/**
 * Information about a storage provider on the
 * Sia network.
 */
public struct Host {
    public var publicKey: String
    public var addresses: [NetAddress]
    public var countryCode: String
    public var latitude: Double
    public var longitude: Double
    public var goodForUpload: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: String, addresses: [NetAddress], countryCode: String, latitude: Double, longitude: Double, goodForUpload: Bool) {
        self.publicKey = publicKey
        self.addresses = addresses
        self.countryCode = countryCode
        self.latitude = latitude
        self.longitude = longitude
        self.goodForUpload = goodForUpload
    }
}

#if compiler(>=6)
extension Host: Sendable {}
#endif


extension Host: Equatable, Hashable {
    public static func ==(lhs: Host, rhs: Host) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        if lhs.countryCode != rhs.countryCode {
            return false
        }
        if lhs.latitude != rhs.latitude {
            return false
        }
        if lhs.longitude != rhs.longitude {
            return false
        }
        if lhs.goodForUpload != rhs.goodForUpload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(addresses)
        hasher.combine(countryCode)
        hasher.combine(latitude)
        hasher.combine(longitude)
        hasher.combine(goodForUpload)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Host {
        return
            try Host(
                publicKey: FfiConverterString.read(from: &buf), 
                addresses: FfiConverterSequenceTypeNetAddress.read(from: &buf), 
                countryCode: FfiConverterString.read(from: &buf), 
                latitude: FfiConverterDouble.read(from: &buf), 
                longitude: FfiConverterDouble.read(from: &buf), 
                goodForUpload: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Host, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterSequenceTypeNetAddress.write(value.addresses, into: &buf)
        FfiConverterString.write(value.countryCode, into: &buf)
        FfiConverterDouble.write(value.latitude, into: &buf)
        FfiConverterDouble.write(value.longitude, into: &buf)
        FfiConverterBool.write(value.goodForUpload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHost_lift(_ buf: RustBuffer) throws -> Host {
    return try FfiConverterTypeHost.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHost_lower(_ value: Host) -> RustBuffer {
    return FfiConverterTypeHost.lower(value)
}


/**
 * A network address of a storage provider on the Sia network.
 */
public struct NetAddress {
    public var `protocol`: AddressProtocol
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`protocol`: AddressProtocol, address: String) {
        self.`protocol` = `protocol`
        self.address = address
    }
}

#if compiler(>=6)
extension NetAddress: Sendable {}
#endif


extension NetAddress: Equatable, Hashable {
    public static func ==(lhs: NetAddress, rhs: NetAddress) -> Bool {
        if lhs.`protocol` != rhs.`protocol` {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`protocol`)
        hasher.combine(address)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetAddress {
        return
            try NetAddress(
                protocol: FfiConverterTypeAddressProtocol.read(from: &buf), 
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NetAddress, into buf: inout [UInt8]) {
        FfiConverterTypeAddressProtocol.write(value.`protocol`, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetAddress_lift(_ buf: RustBuffer) throws -> NetAddress {
    return try FfiConverterTypeNetAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetAddress_lower(_ value: NetAddress) -> RustBuffer {
    return FfiConverterTypeNetAddress.lower(value)
}


/**
 * An ObjectEvent represents an object and whether it was deleted or not.
 */
public struct ObjectEvent {
    public var id: String
    public var deleted: Bool
    public var updatedAt: Date
    public var object: PinnedObject?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, deleted: Bool, updatedAt: Date, object: PinnedObject?) {
        self.id = id
        self.deleted = deleted
        self.updatedAt = updatedAt
        self.object = object
    }
}

#if compiler(>=6)
extension ObjectEvent: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeObjectEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ObjectEvent {
        return
            try ObjectEvent(
                id: FfiConverterString.read(from: &buf), 
                deleted: FfiConverterBool.read(from: &buf), 
                updatedAt: FfiConverterTimestamp.read(from: &buf), 
                object: FfiConverterOptionTypePinnedObject.read(from: &buf)
        )
    }

    public static func write(_ value: ObjectEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTimestamp.write(value.updatedAt, into: &buf)
        FfiConverterOptionTypePinnedObject.write(value.object, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectEvent_lift(_ buf: RustBuffer) throws -> ObjectEvent {
    return try FfiConverterTypeObjectEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectEvent_lower(_ value: ObjectEvent) -> RustBuffer {
    return FfiConverterTypeObjectEvent.lower(value)
}


/**
 * Used to paginate through objects stored in the indexer.
 *
 * When syncing changes from an indexer, `after` should be set to the
 * last `updated_at` timestamp seen, and `key` should be set to the
 * last object's key seen.
 */
public struct ObjectsCursor {
    public var id: String
    public var after: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, after: Date) {
        self.id = id
        self.after = after
    }
}

#if compiler(>=6)
extension ObjectsCursor: Sendable {}
#endif


extension ObjectsCursor: Equatable, Hashable {
    public static func ==(lhs: ObjectsCursor, rhs: ObjectsCursor) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.after != rhs.after {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(after)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeObjectsCursor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ObjectsCursor {
        return
            try ObjectsCursor(
                id: FfiConverterString.read(from: &buf), 
                after: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: ObjectsCursor, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTimestamp.write(value.after, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectsCursor_lift(_ buf: RustBuffer) throws -> ObjectsCursor {
    return try FfiConverterTypeObjectsCursor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectsCursor_lower(_ value: ObjectsCursor) -> RustBuffer {
    return FfiConverterTypeObjectsCursor.lower(value)
}


/**
 * A sector stored on a specific host.
 */
public struct PinnedSector {
    public var root: String
    public var hostKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(root: String, hostKey: String) {
        self.root = root
        self.hostKey = hostKey
    }
}

#if compiler(>=6)
extension PinnedSector: Sendable {}
#endif


extension PinnedSector: Equatable, Hashable {
    public static func ==(lhs: PinnedSector, rhs: PinnedSector) -> Bool {
        if lhs.root != rhs.root {
            return false
        }
        if lhs.hostKey != rhs.hostKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(root)
        hasher.combine(hostKey)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePinnedSector: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PinnedSector {
        return
            try PinnedSector(
                root: FfiConverterString.read(from: &buf), 
                hostKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PinnedSector, into buf: inout [UInt8]) {
        FfiConverterString.write(value.root, into: &buf)
        FfiConverterString.write(value.hostKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedSector_lift(_ buf: RustBuffer) throws -> PinnedSector {
    return try FfiConverterTypePinnedSector.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedSector_lower(_ value: PinnedSector) -> RustBuffer {
    return FfiConverterTypePinnedSector.lower(value)
}


/**
 * A PinnedSlab represents a slab that has been pinned to the indexer.
 */
public struct PinnedSlab {
    public var id: String
    public var encryptionKey: Data
    public var minShards: UInt8
    public var sectors: [PinnedSector]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, encryptionKey: Data, minShards: UInt8, sectors: [PinnedSector]) {
        self.id = id
        self.encryptionKey = encryptionKey
        self.minShards = minShards
        self.sectors = sectors
    }
}

#if compiler(>=6)
extension PinnedSlab: Sendable {}
#endif


extension PinnedSlab: Equatable, Hashable {
    public static func ==(lhs: PinnedSlab, rhs: PinnedSlab) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.encryptionKey != rhs.encryptionKey {
            return false
        }
        if lhs.minShards != rhs.minShards {
            return false
        }
        if lhs.sectors != rhs.sectors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(encryptionKey)
        hasher.combine(minShards)
        hasher.combine(sectors)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePinnedSlab: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PinnedSlab {
        return
            try PinnedSlab(
                id: FfiConverterString.read(from: &buf), 
                encryptionKey: FfiConverterData.read(from: &buf), 
                minShards: FfiConverterUInt8.read(from: &buf), 
                sectors: FfiConverterSequenceTypePinnedSector.read(from: &buf)
        )
    }

    public static func write(_ value: PinnedSlab, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterData.write(value.encryptionKey, into: &buf)
        FfiConverterUInt8.write(value.minShards, into: &buf)
        FfiConverterSequenceTypePinnedSector.write(value.sectors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedSlab_lift(_ buf: RustBuffer) throws -> PinnedSlab {
    return try FfiConverterTypePinnedSlab.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePinnedSlab_lower(_ value: PinnedSlab) -> RustBuffer {
    return FfiConverterTypePinnedSlab.lower(value)
}


/**
 * A sealed object represents an object that has been encrypted
 * for secure offline storage or processing. It can be opened using
 * an app key to retrieve the original object.
 */
public struct SealedObject {
    public var id: String
    public var encryptedDataKey: Data
    public var encryptedMetadataKey: Data
    public var slabs: [Slab]
    public var encryptedMetadata: Data
    public var dataSignature: Data
    public var metadataSignature: Data
    public var createdAt: Date
    public var updatedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, encryptedDataKey: Data, encryptedMetadataKey: Data, slabs: [Slab], encryptedMetadata: Data, dataSignature: Data, metadataSignature: Data, createdAt: Date, updatedAt: Date) {
        self.id = id
        self.encryptedDataKey = encryptedDataKey
        self.encryptedMetadataKey = encryptedMetadataKey
        self.slabs = slabs
        self.encryptedMetadata = encryptedMetadata
        self.dataSignature = dataSignature
        self.metadataSignature = metadataSignature
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

#if compiler(>=6)
extension SealedObject: Sendable {}
#endif


extension SealedObject: Equatable, Hashable {
    public static func ==(lhs: SealedObject, rhs: SealedObject) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.encryptedDataKey != rhs.encryptedDataKey {
            return false
        }
        if lhs.encryptedMetadataKey != rhs.encryptedMetadataKey {
            return false
        }
        if lhs.slabs != rhs.slabs {
            return false
        }
        if lhs.encryptedMetadata != rhs.encryptedMetadata {
            return false
        }
        if lhs.dataSignature != rhs.dataSignature {
            return false
        }
        if lhs.metadataSignature != rhs.metadataSignature {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(encryptedDataKey)
        hasher.combine(encryptedMetadataKey)
        hasher.combine(slabs)
        hasher.combine(encryptedMetadata)
        hasher.combine(dataSignature)
        hasher.combine(metadataSignature)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSealedObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SealedObject {
        return
            try SealedObject(
                id: FfiConverterString.read(from: &buf), 
                encryptedDataKey: FfiConverterData.read(from: &buf), 
                encryptedMetadataKey: FfiConverterData.read(from: &buf), 
                slabs: FfiConverterSequenceTypeSlab.read(from: &buf), 
                encryptedMetadata: FfiConverterData.read(from: &buf), 
                dataSignature: FfiConverterData.read(from: &buf), 
                metadataSignature: FfiConverterData.read(from: &buf), 
                createdAt: FfiConverterTimestamp.read(from: &buf), 
                updatedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: SealedObject, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterData.write(value.encryptedDataKey, into: &buf)
        FfiConverterData.write(value.encryptedMetadataKey, into: &buf)
        FfiConverterSequenceTypeSlab.write(value.slabs, into: &buf)
        FfiConverterData.write(value.encryptedMetadata, into: &buf)
        FfiConverterData.write(value.dataSignature, into: &buf)
        FfiConverterData.write(value.metadataSignature, into: &buf)
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
        FfiConverterTimestamp.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSealedObject_lift(_ buf: RustBuffer) throws -> SealedObject {
    return try FfiConverterTypeSealedObject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSealedObject_lower(_ value: SealedObject) -> RustBuffer {
    return FfiConverterTypeSealedObject.lower(value)
}


/**
 * A Slab represents a contiguous erasure-coded segment of a file stored on the Sia network.
 */
public struct Slab {
    public var encryptionKey: Data
    public var minShards: UInt8
    public var sectors: [PinnedSector]
    public var offset: UInt32
    public var length: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encryptionKey: Data, minShards: UInt8, sectors: [PinnedSector], offset: UInt32, length: UInt32) {
        self.encryptionKey = encryptionKey
        self.minShards = minShards
        self.sectors = sectors
        self.offset = offset
        self.length = length
    }
}

#if compiler(>=6)
extension Slab: Sendable {}
#endif


extension Slab: Equatable, Hashable {
    public static func ==(lhs: Slab, rhs: Slab) -> Bool {
        if lhs.encryptionKey != rhs.encryptionKey {
            return false
        }
        if lhs.minShards != rhs.minShards {
            return false
        }
        if lhs.sectors != rhs.sectors {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encryptionKey)
        hasher.combine(minShards)
        hasher.combine(sectors)
        hasher.combine(offset)
        hasher.combine(length)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSlab: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slab {
        return
            try Slab(
                encryptionKey: FfiConverterData.read(from: &buf), 
                minShards: FfiConverterUInt8.read(from: &buf), 
                sectors: FfiConverterSequenceTypePinnedSector.read(from: &buf), 
                offset: FfiConverterUInt32.read(from: &buf), 
                length: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Slab, into buf: inout [UInt8]) {
        FfiConverterData.write(value.encryptionKey, into: &buf)
        FfiConverterUInt8.write(value.minShards, into: &buf)
        FfiConverterSequenceTypePinnedSector.write(value.sectors, into: &buf)
        FfiConverterUInt32.write(value.offset, into: &buf)
        FfiConverterUInt32.write(value.length, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlab_lift(_ buf: RustBuffer) throws -> Slab {
    return try FfiConverterTypeSlab.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlab_lower(_ value: Slab) -> RustBuffer {
    return FfiConverterTypeSlab.lower(value)
}


/**
 * Provides options for an upload operation.
 */
public struct UploadOptions {
    public var maxInflight: UInt8
    public var dataShards: UInt8
    public var parityShards: UInt8
    /**
     * Optional callback to report upload progress.
     * The callback will be called with the number of bytes uploaded
     * and the total encoded size of the upload.
     */
    public var progressCallback: UploadProgressCallback?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxInflight: UInt8 = UInt8(10), dataShards: UInt8 = UInt8(10), parityShards: UInt8 = UInt8(20), 
        /**
         * Optional callback to report upload progress.
         * The callback will be called with the number of bytes uploaded
         * and the total encoded size of the upload.
         */progressCallback: UploadProgressCallback? = nil) {
        self.maxInflight = maxInflight
        self.dataShards = dataShards
        self.parityShards = parityShards
        self.progressCallback = progressCallback
    }
}

#if compiler(>=6)
extension UploadOptions: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadOptions {
        return
            try UploadOptions(
                maxInflight: FfiConverterUInt8.read(from: &buf), 
                dataShards: FfiConverterUInt8.read(from: &buf), 
                parityShards: FfiConverterUInt8.read(from: &buf), 
                progressCallback: FfiConverterOptionTypeUploadProgressCallback.read(from: &buf)
        )
    }

    public static func write(_ value: UploadOptions, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.maxInflight, into: &buf)
        FfiConverterUInt8.write(value.dataShards, into: &buf)
        FfiConverterUInt8.write(value.parityShards, into: &buf)
        FfiConverterOptionTypeUploadProgressCallback.write(value.progressCallback, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadOptions_lift(_ buf: RustBuffer) throws -> UploadOptions {
    return try FfiConverterTypeUploadOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadOptions_lower(_ value: UploadOptions) -> RustBuffer {
    return FfiConverterTypeUploadOptions.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The protocol used in a network address.
 */

public enum AddressProtocol {
    
    case siaMux
    case quic
}


#if compiler(>=6)
extension AddressProtocol: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressProtocol: FfiConverterRustBuffer {
    typealias SwiftType = AddressProtocol

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressProtocol {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .siaMux
        
        case 2: return .quic
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressProtocol, into buf: inout [UInt8]) {
        switch value {
        
        
        case .siaMux:
            writeInt(&buf, Int32(1))
        
        
        case .quic:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressProtocol_lift(_ buf: RustBuffer) throws -> AddressProtocol {
    return try FfiConverterTypeAddressProtocol.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressProtocol_lower(_ value: AddressProtocol) -> RustBuffer {
    return FfiConverterTypeAddressProtocol.lower(value)
}


extension AddressProtocol: Equatable, Hashable {}







public enum AppKeyError: Swift.Error {

    
    
    case InvalidLength(message: String)
    
    case SignatureLength(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppKeyError: FfiConverterRustBuffer {
    typealias SwiftType = AppKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLength(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .SignatureLength(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppKeyError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidLength(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .SignatureLength(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppKeyError_lift(_ buf: RustBuffer) throws -> AppKeyError {
    return try FfiConverterTypeAppKeyError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppKeyError_lower(_ value: AppKeyError) -> RustBuffer {
    return FfiConverterTypeAppKeyError.lower(value)
}


extension AppKeyError: Equatable, Hashable {}




extension AppKeyError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum BuilderError: Swift.Error {

    
    
    case Error(message: String)
    
    case InvalidState(message: String)
    
    case Crypto(message: String)
    
    case JoinError(message: String)
    
    case Custom(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuilderError: FfiConverterRustBuffer {
    typealias SwiftType = BuilderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuilderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Error(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidState(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Crypto(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Custom(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuilderError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Error(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidState(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Crypto(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Custom(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilderError_lift(_ buf: RustBuffer) throws -> BuilderError {
    return try FfiConverterTypeBuilderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilderError_lower(_ value: BuilderError) -> RustBuffer {
    return FfiConverterTypeBuilderError.lower(value)
}


extension BuilderError: Equatable, Hashable {}




extension BuilderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum ConnectError: Swift.Error {

    
    
    case AppClient(message: String)
    
    case JoinError(message: String)
    
    case Custom(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectError: FfiConverterRustBuffer {
    typealias SwiftType = ConnectError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AppClient(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Custom(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AppClient(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Custom(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectError_lift(_ buf: RustBuffer) throws -> ConnectError {
    return try FfiConverterTypeConnectError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectError_lower(_ value: ConnectError) -> RustBuffer {
    return FfiConverterTypeConnectError.lower(value)
}


extension ConnectError: Equatable, Hashable {}




extension ConnectError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum DownloadError: Swift.Error {

    
    
    case Download(message: String)
    
    case JoinError(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDownloadError: FfiConverterRustBuffer {
    typealias SwiftType = DownloadError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DownloadError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Download(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DownloadError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Download(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadError_lift(_ buf: RustBuffer) throws -> DownloadError {
    return try FfiConverterTypeDownloadError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadError_lower(_ value: DownloadError) -> RustBuffer {
    return FfiConverterTypeDownloadError.lower(value)
}


extension DownloadError: Equatable, Hashable {}




extension DownloadError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum EncryptionKeyParseError: Swift.Error {

    
    
    case Base64(message: String)
    
    case KeyLength(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptionKeyParseError: FfiConverterRustBuffer {
    typealias SwiftType = EncryptionKeyParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionKeyParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Base64(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .KeyLength(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptionKeyParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Base64(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .KeyLength(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKeyParseError_lift(_ buf: RustBuffer) throws -> EncryptionKeyParseError {
    return try FfiConverterTypeEncryptionKeyParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKeyParseError_lower(_ value: EncryptionKeyParseError) -> RustBuffer {
    return FfiConverterTypeEncryptionKeyParseError.lower(value)
}


extension EncryptionKeyParseError: Equatable, Hashable {}




extension EncryptionKeyParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum Error: Swift.Error {

    
    
    case Sdk(message: String)
    
    case HexParseError(message: String)
    
    case SealedObject(message: String)
    
    case JoinError(message: String)
    
    case Custom(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeError: FfiConverterRustBuffer {
    typealias SwiftType = Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Sdk(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .HexParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .SealedObject(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Custom(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Error, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Sdk(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .HexParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .SealedObject(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Custom(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lift(_ buf: RustBuffer) throws -> Error {
    return try FfiConverterTypeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lower(_ value: Error) -> RustBuffer {
    return FfiConverterTypeError.lower(value)
}


extension Error: Equatable, Hashable {}




extension Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum IoError: Swift.Error {

    
    
    case Io(message: String)
    
    case Closed(message: String)
    
    case Cancelled(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIOError: FfiConverterRustBuffer {
    typealias SwiftType = IoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Io(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Closed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Cancelled(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Io(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Closed(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Cancelled(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIOError_lift(_ buf: RustBuffer) throws -> IoError {
    return try FfiConverterTypeIOError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIOError_lower(_ value: IoError) -> RustBuffer {
    return FfiConverterTypeIOError.lower(value)
}


extension IoError: Equatable, Hashable {}




extension IoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum ObjectError: Swift.Error {

    
    
    case SealedObject(message: String)
    
    case Encoding(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeObjectError: FfiConverterRustBuffer {
    typealias SwiftType = ObjectError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ObjectError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SealedObject(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Encoding(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ObjectError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SealedObject(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Encoding(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectError_lift(_ buf: RustBuffer) throws -> ObjectError {
    return try FfiConverterTypeObjectError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeObjectError_lower(_ value: ObjectError) -> RustBuffer {
    return FfiConverterTypeObjectError.lower(value)
}


extension ObjectError: Equatable, Hashable {}




extension ObjectError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum SeedError: Swift.Error {

    
    
    case InvalidMnemonic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeedError: FfiConverterRustBuffer {
    typealias SwiftType = SeedError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMnemonic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidMnemonic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedError_lift(_ buf: RustBuffer) throws -> SeedError {
    return try FfiConverterTypeSeedError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedError_lower(_ value: SeedError) -> RustBuffer {
    return FfiConverterTypeSeedError.lower(value)
}


extension SeedError: Equatable, Hashable {}




extension SeedError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum UploadError: Swift.Error {

    
    
    case Closed(message: String)
    
    case Io(message: String)
    
    case Upload(message: String)
    
    case JoinError(message: String)
    
    case Custom(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadError: FfiConverterRustBuffer {
    typealias SwiftType = UploadError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Closed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Io(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Upload(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Custom(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UploadError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Closed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Io(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Upload(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Custom(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadError_lift(_ buf: RustBuffer) throws -> UploadError {
    return try FfiConverterTypeUploadError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadError_lower(_ value: UploadError) -> RustBuffer {
    return FfiConverterTypeUploadError.lower(value)
}


extension UploadError: Equatable, Hashable {}




extension UploadError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePinnedObject: FfiConverterRustBuffer {
    typealias SwiftType = PinnedObject?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePinnedObject.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePinnedObject.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSDK: FfiConverterRustBuffer {
    typealias SwiftType = Sdk?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSDK.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSDK.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUploadProgressCallback: FfiConverterRustBuffer {
    typealias SwiftType = UploadProgressCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUploadProgressCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUploadProgressCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeObjectsCursor: FfiConverterRustBuffer {
    typealias SwiftType = ObjectsCursor?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeObjectsCursor.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeObjectsCursor.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePinnedObject: FfiConverterRustBuffer {
    typealias SwiftType = [PinnedObject]

    public static func write(_ value: [PinnedObject], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePinnedObject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PinnedObject] {
        let len: Int32 = try readInt(&buf)
        var seq = [PinnedObject]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePinnedObject.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHost: FfiConverterRustBuffer {
    typealias SwiftType = [Host]

    public static func write(_ value: [Host], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHost.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Host] {
        let len: Int32 = try readInt(&buf)
        var seq = [Host]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHost.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNetAddress: FfiConverterRustBuffer {
    typealias SwiftType = [NetAddress]

    public static func write(_ value: [NetAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [NetAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeObjectEvent: FfiConverterRustBuffer {
    typealias SwiftType = [ObjectEvent]

    public static func write(_ value: [ObjectEvent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeObjectEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ObjectEvent] {
        let len: Int32 = try readInt(&buf)
        var seq = [ObjectEvent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeObjectEvent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePinnedSector: FfiConverterRustBuffer {
    typealias SwiftType = [PinnedSector]

    public static func write(_ value: [PinnedSector], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePinnedSector.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PinnedSector] {
        let len: Int32 = try readInt(&buf)
        var seq = [PinnedSector]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePinnedSector.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSlab: FfiConverterRustBuffer {
    typealias SwiftType = [Slab]

    public static func write(_ value: [Slab], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSlab.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slab] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slab]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSlab.read(from: &buf))
        }
        return seq
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureIndexdFfiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountIndexdFfi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Calculates the encoded size of data given the original size and erasure coding parameters.
 */
public func encodedSize(size: UInt64, dataShards: UInt8, parityShards: UInt8) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_func_encoded_size(
        FfiConverterUInt64.lower(size),
        FfiConverterUInt8.lower(dataShards),
        FfiConverterUInt8.lower(parityShards),$0
    )
})
}
/**
 * Generates a new BIP-32 12-word recovery phrase.
 */
public func generateRecoveryPhrase() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_indexd_ffi_fn_func_generate_recovery_phrase($0
    )
})
}
/**
 * Sets a foreign logger to receive log messages from the SDK.
 */
public func setLogger(logger: Logger, level: String)  {try! rustCall() {
    uniffi_indexd_ffi_fn_func_set_logger(
        FfiConverterTypeLogger_lower(logger),
        FfiConverterString.lower(level),$0
    )
}
}
/**
 * Validates a BIP-32 recovery phrase.
 */
public func validateRecoveryPhrase(phrase: String)throws   {try rustCallWithError(FfiConverterTypeSeedError_lift) {
    uniffi_indexd_ffi_fn_func_validate_recovery_phrase(
        FfiConverterString.lower(phrase),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_indexd_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_indexd_ffi_checksum_func_encoded_size() != 51818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_func_generate_recovery_phrase() != 35343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_func_set_logger() != 36651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_func_validate_recovery_phrase() != 56714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_appkey_export() != 242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_appkey_public_key() != 45376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_appkey_sign() != 33860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_appkey_verify_signature() != 47305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_builder_connected() != 41238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_builder_register() != 34757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_builder_request_connection() != 58655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_builder_response_url() != 18056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_builder_wait_for_approval() != 43963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_encryptionkey_export() != 1252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_logger_info() != 54729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_logger_warn() != 48239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_logger_error() != 23088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_logger_debug() != 42085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_packedupload_add() != 36669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_packedupload_finalize() != 9491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_packedupload_remaining() != 3225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_created_at() != 22273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_id() != 62787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_metadata() != 60113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_seal() != 13608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_size() != 48206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_slabs() != 21596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_update_metadata() != 65197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_pinnedobject_updated_at() != 1712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_reader_read() != 8865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_account() != 50707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_app_key() != 63583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_delete_object() != 39351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_download() != 54684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_hosts() != 11119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_object() != 24221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_object_events() != 7322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_pin_object() != 26709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_prune_slabs() != 23027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_share_object() != 18462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_shared_object() != 51661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_slab() != 48470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_update_object_metadata() != 31500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_upload() != 42177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_sdk_upload_packed() != 58097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_uploadprogresscallback_progress() != 10119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_method_writer_write() != 5185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_constructor_appkey_new() != 62590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_constructor_builder_new() != 25722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_constructor_encryptionkey_parse() != 42073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_indexd_ffi_checksum_constructor_pinnedobject_open() != 56501) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLogger()
    uniffiCallbackInitReader()
    uniffiCallbackInitUploadProgressCallback()
    uniffiCallbackInitWriter()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureIndexdFfiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all